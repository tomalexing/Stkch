{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n// 2. This code loads the IFrame Player API code asynchronously.\nvar tag = document.createElement('script');\n\ntag.src = \"https://www.youtube.com/iframe_api\";\nvar firstScriptTag = document.getElementsByTagName('script')[0];\nfirstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n\n// 3. This function creates an <iframe> (and YouTube player)\n//    after the API code downloads.\nvar player;\nfunction onYouTubeIframeAPIReady() {\n  player = new YT.Player('player', {\n    height: '547',\n    width: '978',\n    videoId: 'M7lc1UVf-VE',\n    events: {\n      'onReady': onPlayerReady,\n      'onStateChange': onPlayerStateChange\n    }\n  });\n}\n\n// 4. The API will call this function when the video player is ready.\nfunction onPlayerReady(event) {\n  event.target.playVideo();\n}\n\n// 5. The API calls this function when the player's state changes.\n//    The function indicates that when playing a video (state=1),\n//    the player should play for six seconds and then stop.\nvar done = false;\nfunction onPlayerStateChange(event) {\n  if (event.data == YT.PlayerState.PLAYING && !done) {\n    setTimeout(stopVideo, 6000);\n    done = true;\n  }\n}\nfunction stopVideo() {\n  player.stopVideo();\n}\n\n// import scroll     from './modules/scroll-controller';\n// import events     from './modules/events';\n// import animations from './modules/animations';\n// import activateFullpage from './modules/fp';\n\n// const $win          = $(window);\n// const mq            = window.matchMedia('(min-width: 1024px)');\n// let lastSectionName = null;\n\n// // functions\n// function disableScroll() {\n//     scroll.disable();\n//     $.fn.fullpage.setAllowScrolling(false);\n//     $.fn.fullpage.setKeyboardScrolling(false);\n// }\n\n// function enableScroll() {\n//     scroll.enable();\n//     $.fn.fullpage.setAllowScrolling(true);\n//     $.fn.fullpage.setKeyboardScrolling(true);\n// }\n\n// function setAnimationsProgress(val = 0) {\n//     for (let key in animations) {\n//         if (!animations.hasOwnProperty(key) || key === 'intro') continue;\n//         animations[key].progress(val);\n//     }\n// }\n\n// function windowResizeHandler(mediaQuery) {\n//     if (mediaQuery.matches) {\n//         setAnimationsProgress(0);\n//     } else {\n//         setAnimationsProgress(1);\n//     }\n// }\n\n// // events\n// mq.addListener(function() {\n//     windowResizeHandler(this);\n// });\n\n// $win.on('mousewheel DOMMouseScroll scroll touchmove', (e) => {\n//     if (!intro.wasAnimated()) {\n//         intro.disableParallax();\n//         intro.playAnimations();\n//     }\n// });\n\n// events.subscribe(events.names.FP_INIT, (props) => {\n//     let { slides } = props;\n//     let activeSlide = slides.filter('.active');\n//     activeSlide.prevAll().addClass('prev');\n//     activeSlide.nextAll().addClass('next');\n// });\n\n// events.subscribe(events.names.INTRO_END_ANIMATIONS, enableScroll);\n\n// events.subscribe(events.names.FP_BEFORE_CHANGE, (props) => {\n//     let { slide, direction } = props;\n\n//     slide.prevAll().removeClass('next').addClass('prev');\n//     slide.nextAll().removeClass('prev').addClass('next');\n\n//     switch (direction) {\n//     case 'down':\n//         slide.addClass('prev');\n//         break;\n//     case 'up':\n//         slide.addClass('next');\n//         break;\n//     }\n// });\n\n// events.subscribe(events.names.FP_AFTER_CHANGE, (props) => {\n//     let { slide, index, anchorLink } = props;\n//     let sectionAnim = animations[anchorLink];\n//     let prevSectionAnim = animations[lastSectionName];\n\n//     slide.removeClass('prev next');\n\n//     $('.pagination__link')\n//         .removeClass('is-active')\n//         .eq(index - 1)\n//         .addClass('is-active');\n\n//     if (mq.matches) {\n//         if (sectionAnim) sectionAnim.play();\n//         if (prevSectionAnim) prevSectionAnim.progress(0).pause();\n//     }\n//     lastSectionName = anchorLink;\n// });\n\n// // events.subscribe(events.names.FP_LOOP_TOP, (props) => {\n// //     disableScroll();\n// //     intro.playAnimationsReverse();\n// // });\n\n// events.subscribe(events.names.FP_INTRO_FOCUSIN, () => {\n//     $('.links').removeClass('is-dark');\n//     $('.pagination').removeClass('is-dark');\n// });\n\n// events.subscribe(events.names.FP_INTRO_FOCUSOUT, () => {\n//     $('.links').addClass('is-dark');\n//     $('.pagination').addClass('is-dark');\n// });\n\n// // initial actions\n// activateFullpage();\n// intro.enableParallax();\n// disableScroll();\n// windowResizeHandler(mq);\n\n},{}]},{},[1]);\n"],"file":"app.js","sourceRoot":"/source/"}